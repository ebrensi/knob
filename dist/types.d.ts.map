{"mappings":"ACIA,kBAAkB,OAAO,GAAG,MAAM,CAAC;AAEnC,QAAA,MAAM;;;;;;;;;;;;;;;;;;;;CA0BL,CAAC;AAEF,0BAA0B,qBAAqB,GAAG;IAChD,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,IAAI,CAAC;CACpC,CAAC;AAEF,sBAAsB;IACpB,OAAO,EAAE,WAAW,CAAC;IACrB,MAAM,EAAE,iBAAiB,CAAC;IAC1B,KAAK,EAAE,gBAAgB,CAAC;IACxB,KAAK,EAAE,eAAe,CAAC;IACvB,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,MAAM,MAAM,CAAC;IACvB,QAAQ,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,OAAO,KAAK,IAAI,CAAC;CACpD,CAAA;AAGD,0BAA0B,cAAc,GAAG,cAAc,CAAA;AAEzD,wBAAgB,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,WAAW,CAAC,GAAG,WAAW,CA6HnE;AA0CD,eAAe,IAAI,CAAA","sources":["src/src/handleChange.ts","src/src/Knob.ts","src/Knob.ts"],"sourcesContent":[null,null,"import { handleChange } from \"./handleChange\";\n\nconst DEBOUNCE_DELAY = 16; // ms\n\ntype CursorType = boolean | number;\n\nconst DefaultOptions = {\n  value: 50,\n\n  min: 0,\n  max: 100,\n  step: 1,\n\n  cursor: <CursorType>false,\n  thickness: 0.35,\n  lineCap: <CanvasRenderingContext2D[\"lineCap\"]>\"butt\",\n  readOnly: false,\n  displayInput: true,\n\n  width: 200,\n  height: 200,\n\n  bgColor: \"#EEEEEE\",\n  fgColor: \"#87CEEB\",\n  label: \"\",\n  labelColor: \"#888\",\n\n  angleOffset: 0,\n  angleArc: 360,\n\n  className: \"\",\n  activeClass: \"\",\n};\n\nexport type KnobOptions = typeof DefaultOptions & {\n  callback?: (value: number) => void;\n};\n\ntype KnobProperties = {\n  options: KnobOptions;\n  canvas: HTMLCanvasElement;\n  input: HTMLInputElement;\n  label: HTMLSpanElement;\n  value: number;\n  getValue: () => number;\n  setValue: (value: number, event?: boolean) => void;\n}\n\ntype ProtoKnob = Partial<KnobProperties> & HTMLDivElement\nexport type KnobElement = KnobProperties & HTMLDivElement\n\nexport function Knob(knobOptions: Partial<KnobOptions>): KnobElement {\n  const options = { ...DefaultOptions, ...knobOptions };\n\n  // Create Canvas Element\n  const canvas = document.createElement(\"canvas\");\n  canvas.height = options.height;\n  canvas.width = options.width;\n  canvas.style.position = \"absolute\";\n  const ctx = <CanvasRenderingContext2D>canvas.getContext(\"2d\");\n\n  // Create Input Element\n  const fontScale =\n    Math.max(\n      String(Math.abs(options.max)).length,\n      String(Math.abs(options.min)).length,\n      2\n    ) + 2;\n\n  const input = document.createElement(\"input\");\n  input.value = String(options.value);\n  input.disabled = options.readOnly;\n\n  const lineWidth = (options.width / 2) * options.thickness;\n\n  Object.assign(input.style, {\n    position: \"absolute\",\n    top: `${options.width / 2 - options.width / 7}px`,\n    left: `${lineWidth}px`,\n    width: `${options.width - lineWidth * 2}px`,\n    \"vertical-align\": \"middle\",\n    border: 0,\n    background: \"none\",\n    font: `bold ${(options.width / fontScale) >> 0}px Arial`,\n    \"text-align\": \"center\",\n    color: options.fgColor,\n    padding: \"0px\",\n    \"-webkit-appearance\": \"none\",\n    display: !options.displayInput ? \"none\" : \"\",\n  });\n\n  // Create Label Element\n  const label = document.createElement(\"span\");\n  Object.assign(label.style, {\n    color: options.labelColor,\n    position: \"absolute\",\n    bottom: 0,\n    \"font-size\": \"80%\",\n    \"text-align\": \"center\",\n    \"pointer-events\": \"none\",\n    top: `${options.width / 2 + options.width / 8 - 3}px`,\n    left: 0,\n    right: 0,\n  });\n  label.innerHTML = options.label;\n\n  // Create div element\n  const div: ProtoKnob = document.createElement(\"div\");\n  Object.assign(div.style, {\n    display: \"inline-block\",\n    position: \"relative\",\n    height: `${options.height}px`,\n    width: `${options.width}px`,\n    \"touch-action\": \"none\",\n  });\n  if (options.className) {\n    div.classList.add(options.className);\n  }\n\n  div.appendChild(canvas);\n  div.appendChild(input);\n  div.appendChild(label);\n\n  // Attach HTML Elements to the div element\n  Object.assign(div, { options, canvas, input, label });\n\n  let renderedValue = options.value;\n  let animating = false;\n  let _timeout: number\n\n  function refreshCanvas() {\n    if (renderedValue === options.value) {\n      animating = false;\n    } else {\n      animating = true;\n      renderedValue = options.value;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      draw(options, ctx);\n      input.value = String(options.value);\n      window.requestAnimationFrame(refreshCanvas);\n    }\n  }\n\n  // Attach methods to the div\n  div.getValue = () => options.value;\n\n  div.setValue = (value: number, event?: boolean) => {\n    value = Math.min(options.max, Math.max(options.min, value));\n    options.value = value;\n    div.value = value;\n    if (!animating) {\n      refreshCanvas();\n    }\n    if (event === true && div.onchange) {\n      /*\n       * Perform debounced callback\n       */\n      let timeout = _timeout;\n      window.clearTimeout(timeout);\n      timeout = window.setTimeout(div.onchange, DEBOUNCE_DELAY);\n      _timeout = timeout;\n    }\n  };\n\n  input.addEventListener(\"change\", (e) => {\n    const el = <HTMLInputElement>e.target;\n    div.setValue?.(+el.value);\n  });\n\n  draw(options, ctx);\n\n  if (!options.readOnly) {\n    handleChange(<KnobElement>div);\n  }\n\n  return <KnobElement>div;\n}\n\nfunction draw(options: KnobOptions, ctx: CanvasRenderingContext2D) {\n  // deg to rad\n  const angleOffset = (options.angleOffset * Math.PI) / 180;\n  const angleArc = (options.angleArc * Math.PI) / 180;\n\n  const angle =\n    ((options.value - options.min) * angleArc) / (options.max - options.min);\n\n  const xy = options.width / 2;\n  const lineWidth = xy * options.thickness;\n  const radius = xy - lineWidth / 2;\n\n  const startAngle = 1.5 * Math.PI + angleOffset;\n  const endAngle = 1.5 * Math.PI + angleOffset + angleArc;\n\n  let startAt = startAngle;\n  let endAt = startAt + angle;\n\n  if (options.cursor) {\n    const cursorSize =\n      options.cursor === true ? options.thickness : options.cursor;\n    const cursorExt = cursorSize / 100 || 1;\n    startAt = endAt - cursorExt;\n    endAt = endAt + cursorExt;\n  }\n\n  ctx.lineWidth = lineWidth;\n  ctx.lineCap = options.lineCap;\n\n  ctx.beginPath();\n  ctx.strokeStyle = options.bgColor;\n  ctx.arc(xy, xy, radius, endAngle, startAngle, true);\n  ctx.stroke();\n\n  ctx.beginPath();\n  ctx.strokeStyle = options.fgColor;\n  ctx.arc(xy, xy, radius, startAt, endAt, false);\n  ctx.stroke();\n}\n\nexport default Knob\n"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}