{"mappings":"ACEA,kBAAkB,OAAO,GAAG,MAAM,CAAA;AAElC,QAAA,MAAM;;;;;;;;;;;;;;;;;;;;CA0BL,CAAC;AAEF,0BAA0B,qBAAqB,GAAG;IAChD,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,IAAI,CAAA;CACnC,CAAC;AAEF;IACE,OAAO,EAAE,WAAW,CAAA;IACpB,OAAO,EAAE,iBAAiB,CAAA;IAC1B,IAAI,EAAE,wBAAwB,CAAA;IAC9B,MAAM,EAAE,gBAAgB,CAAA;IACxB,MAAM,EAAE,eAAe,CAAA;IACvB,IAAI,EAAE,cAAc,CAAA;IACpB,UAAU,EAAE,OAAO,CAAA;IACnB,cAAc,EAAE,MAAM,CAAA;gBAEV,WAAW,EAAE,OAAO,CAAC,WAAW,CAAC;IA0F7C,IAAI;IAIJ,QAAQ;IAIR,QAAQ,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,OAAO,GAAG,IAAI;IAW9C,aAAa;IAab,IAAI;CAyCL","sources":["src/src/handleChange.ts","src/src/Knob.ts","src/Knob.ts"],"sourcesContent":[null,null,"import { handleChange } from \"./handleChange\";\n\ntype CursorType = boolean | number\n\nconst DefaultOptions = {\n  value: 50,\n\n  min: 0,\n  max: 100,\n  step: 1,\n\n  cursor: <CursorType>false,\n  thickness: 0.35,\n  lineCap: <CanvasRenderingContext2D[\"lineCap\"]>\"butt\",\n  readOnly: false,\n  displayInput: true,\n\n  width: 200,\n  height: 200,\n\n  bgColor: \"#EEEEEE\",\n  fgColor: \"#87CEEB\",\n  label: \"\",\n  labelColor: \"#888\",\n\n  angleOffset: 0,\n  angleArc: 360,\n\n  className: \"\",\n  activeClass: \"\",\n};\n\nexport type KnobOptions = typeof DefaultOptions & {\n  callback?: (value: number) => void\n};\n\nexport class Knob {\n  options: KnobOptions\n  _canvas: HTMLCanvasElement\n  _ctx: CanvasRenderingContext2D\n  _input: HTMLInputElement\n  _label: HTMLSpanElement\n  _div: HTMLDivElement\n  _animating: boolean\n  _renderedValue: number\n\n  constructor(knobOptions: Partial<KnobOptions>){\n    const options = { ...DefaultOptions, ...knobOptions };\n    this.options = options\n\n    // Create Canvas Element\n    const canvas = document.createElement(\"canvas\");\n    this._canvas = canvas\n    canvas.height = options.height;\n    canvas.width = options.width;\n    canvas.style.position = \"absolute\";\n    this._ctx = <CanvasRenderingContext2D>canvas.getContext(\"2d\");\n\n    // Create Input Element\n    const fontScale =\n      Math.max(\n        String(Math.abs(options.max)).length,\n        String(Math.abs(options.min)).length,\n        2\n      ) + 2;\n\n    const input = document.createElement(\"input\");\n    this._input = input\n    input.value = String(options.value);\n    input.disabled = options.readOnly;\n    input.addEventListener(\"change\", (e) => {\n      const el = <HTMLInputElement>e.target\n      this.setValue(+el.value);\n    });\n\n    const lineWidth = (options.width / 2) * options.thickness\n\n    Object.assign(input.style, {\n      position: \"absolute\",\n      top: `${options.width / 2 - options.width / 7}px`,\n      left: `${lineWidth}px`,\n      width: `${options.width - lineWidth * 2}px`,\n      \"vertical-align\": \"middle\",\n      border: 0,\n      background: \"none\",\n      font: `bold ${((options.width / fontScale) >> 0)}px Arial`,\n      \"text-align\": \"center\",\n      color: options.fgColor,\n      padding: \"0px\",\n      \"-webkit-appearance\": \"none\",\n      display: !options.displayInput ? \"none\" : \"\",\n    });\n\n    // Create Label Element\n    const label = document.createElement(\"span\");\n    this._label = label\n    Object.assign(label.style, {\n      color: options.labelColor,\n      position: \"absolute\",\n      bottom: 0,\n      \"font-size\": \"80%\",\n      \"text-align\": \"center\",\n      \"pointer-events\": \"none\",\n      top: `${options.width / 2 + options.width / 8 - 3}px`,\n      left: 0,\n      right: 0\n    })\n    label.innerHTML = options.label\n\n    // Create div element\n    const div = document.createElement(\"div\")\n    this._div = div\n    Object.assign(div.style, {\n      display: \"inline-block\",\n      position: \"relative\",\n      height: `${options.height}px`,\n      width: `${options.width}px`,\n    })\n    if (options.className) {\n      div.classList.add(options.className)\n    }\n\n    div.appendChild(canvas);\n    div.appendChild(input);\n    div.appendChild(label);\n\n    this._renderedValue = options.value;\n    this._animating = false;\n\n    this.draw();\n\n    if (!options.readOnly) {\n      handleChange(this);\n    }\n  }\n\n  node() {\n    return this._div\n  }\n\n  getValue() {\n    return this.options.value\n  }\n\n  setValue(value: number, event?: boolean): void {\n    value = Math.min(this.options.max, Math.max(this.options.min, value));\n    this.options.value = value;\n    if (!this._animating) {\n      this.refreshCanvas();\n    }\n    if (event === true && this.options.callback) {\n      this.options.callback(value);\n    }\n  }\n\n  refreshCanvas() {\n    if (this._renderedValue === this.options.value) {\n      this._animating = false;\n    } else {\n      this._animating = true;\n      this._renderedValue = this.options.value;\n      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n      this.draw();\n      this._input.value = String(this.options.value);\n      window.requestAnimationFrame(this.refreshCanvas.bind(this));\n    }\n  }\n\n  draw() {\n    const options = this.options\n    const ctx = this._ctx\n\n    // deg to rad\n    const angleOffset = (options.angleOffset * Math.PI) / 180;\n    const angleArc = (options.angleArc * Math.PI) / 180;\n\n    const angle =\n      ((options.value - options.min) * angleArc) / (options.max - options.min);\n\n    const xy = options.width / 2;\n    const lineWidth = xy * options.thickness;\n    const radius = xy - lineWidth / 2;\n\n    const startAngle = 1.5 * Math.PI + angleOffset;\n    var endAngle = 1.5 * Math.PI + angleOffset + angleArc;\n\n    let startAt = startAngle;\n    let endAt = startAt + angle;\n\n    if (options.cursor) {\n      const cursorSize = (options.cursor === true)? options.thickness : options.cursor\n      const cursorExt = cursorSize / 100 || 1;\n      startAt = endAt - cursorExt;\n      endAt = endAt + cursorExt;\n    }\n\n    ctx.lineWidth = lineWidth;\n    ctx.lineCap = options.lineCap;\n\n    ctx.beginPath();\n    ctx.strokeStyle = options.bgColor;\n    ctx.arc(xy, xy, radius, endAngle, startAngle, true);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.strokeStyle = options.fgColor;\n    ctx.arc(xy, xy, radius, startAt, endAt, false);\n    ctx.stroke();\n  }\n}\n\n\n"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}